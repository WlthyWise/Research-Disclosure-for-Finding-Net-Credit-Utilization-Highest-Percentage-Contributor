\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}

% Replaced the old 'pseudocode' package with the modern 'algorithm' 
% and 'algpseudocode' packages, which support the syntax being used.
\usepackage{algorithm}
\usepackage{algpseudocode}

\title{Proof of Correctness for Net Credit Limit Utilization Minimization Algorithm}
\author{}
\date{}

\begin{document}

\maketitle

\section{Problem Definition}

We are given a set of credit card accounts, which can be defined as follows:
\begin{itemize}
    \item $L = \langle l_1, \dots, l_{n} \rangle$ is a sequence of credit limits.
    \item $b = \langle b_1, \dots, b_{n} \rangle$ is a sequence of corresponding credit card balances.
    \item $C = \{(b_1, l_1), \dots, (b_{n}, l_{n})\}$ is a set of tuples, where each tuple represents a single credit card account.
    \item $n$ is the total number of credit card accounts. We assume $n > 0$.
    \item $k$ is the loop index, where $0 < k < n$.
\end{itemize}

We want to prove the correctness of an algorithm that iterates through the credit card accounts, which are pre-sorted by their balance in ascending order.

\section{Pseudocode}

The algorithm first sorts the set of credit card accounts $C$ based on $ \frac{b_{i}}{\sum_{i=1}^{n} L_i} $ and then iterates from the first credit card account to the second-to-last credit card account in the sorted order.

% Switched to the 'algorithm' and 'algorithmic' environments.
% Updated the syntax to match the 'algpseudocode' package.
% This includes using \Procedure, \State, \If, \For, \gets, \Call, and \Comment.
% Also ensured all mathematical expressions are in math mode ($...$).
\begin{algorithm}
\caption{ProcessSortedBalances($C$)}
\begin{algorithmic}[1] 
\Procedure{ProcessSortedBalances}{$C$}
    \Comment{Input: A set of credit card accounts tuples $C = \{(b_i, l_i)\}$}
    \Comment{Output: Processes credit card accounts in order of increasing balance.}
    \State $S \gets \Call{SortByBalance}{C}$ \Comment{Sort $C$ by balance $b_i$ in ascending order}
    \State $n \gets \Call{Length}{S}$
    \If{$n > 0$}
        \For{$k \gets 1$ to $n-1$}
            \State \Comment{Loop body. Operations on $S_k$ and $S_{k+1}$ could be performed here.}
            \State \Comment{The loop invariant holds at the beginning of each iteration.}
        \EndFor
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Loop Invariant Proof}

We will prove the correctness using the following loop invariant. The invariant is evaluated at the start of each iteration of the \textbf{FOR} loop for index $k$.

\subsection{The Invariant}

\textbf{Loop Invariant:} At the start of the iteration for a given index $k$ (where $0 < k < n$), the following inequality holds:
$$ \frac{b_{k}}{\sum_{i=1}^{n} L_i} < \frac{b_{k+1}}{\sum_{i=1}^{n} L_i} $$
where $b_k$ and $b_{k+1}$ are the balances of the credit card accounts at indices $k$ and $k+1$ in the sorted sequence $S$. Since the denominator $\sum_{i=1}^{n} L_i$ is a positive constant (assuming credit limits are positive), this invariant is equivalent to stating that $b_k < b_{k+1}$.

\subsection{Proof by Induction}

\subsubsection{Initialization}
We must show that the invariant is true before the first loop iteration.
The loop starts with $k=1$. The invariant for this case is:
$$ \frac{b_{1}}{\sum_{i=1}^{n} L_i} < \frac{b_{2}}{\sum_{i=1}^{n} L_i} $$
This simplifies to $\frac{b_{2}}{\sum_{i=1}^{n} L_i} < \frac{b_{3}}{\sum_{i=1}^{n} L_i}$.

The pseudocode's first step is to sort the sequence of credit card accounts $S$ by the ratio of the balance and the sum of the credit limits in ascending order. By the definition of this sorting operation, for any two adjacent elements $S_i$ and $S_{i+1}$, the ratio of the balance and the sum of the credit limits by $S_i$ must be less than or equal to the ratio of the balance and the sum of the credit limits by $S_{i+1}$. Assuming no two credit card accounts have the exact same ratio of the balance and the sum of the credit limits, this means $\frac{b_{1}}{\sum_{i=1}^{n} L_i} < \frac{b_{2}}{\sum_{i=1}^{n} L_i}$. Therefore, the invariant holds for the initial case $k=1$.

\subsubsection{Maintenance}
We assume the loop invariant holds for an arbitrary iteration $k$, and we must show that it holds for the next iteration, $k+1$. The loop runs as long as $k < n-1$. Let's assume the invariant holds for an iteration $j$, where $0 < j < n-1$.

\textbf{Assumption:}
$$ \frac{b_{j}}{\sum_{i=1}^{n} L_i} < \frac{b_{j+1}}{\sum_{i=1}^{n} L_i} \quad (\text{which implies } b_j < b_{j+1}) $$

We need to prove that at the start of the next iteration, where the index is $j+1$, the invariant still holds. The invariant for index $j+1$ is:
$$ \frac{b_{j+1}}{\sum_{i=1}^{n} L_i} < \frac{b_{j+2}}{\sum_{i=1}^{n} L_i} $$
This inequality is equivalent to $b_{j+1} < b_{j+2}$.

Just as in the initialization step, this condition is guaranteed to be true because the sequence $S$ was sorted by the ratio of the balance and the sum of the credit limits as a precondition. The loop does not modify the order of elements in $S$. Thus, for any valid index $j+1$, it must be that $b_{j+1} < b_{j+2}$. The invariant is therefore maintained through each iteration of the loop.

\subsubsection{Termination}
The loop terminates when $k = n-1$. The final iteration of the loop body is for $k = n-1$.

At the start of this final iteration, the maintenance property guarantees that the invariant holds for $k = n-1$, which is:
$$ \frac{b_{n-2}}{\sum_{i=1}^{n} L_i} < \frac{b_{n-1}}{\sum_{i=1}^{n} L_i} $$
This shows that $b_{n-2} < b_{n-1}$.

When the loop terminates, we have successfully shown that the invariant $b_k < b_{k+1}$ held for all $k$ from $0$ to $n-2$. This means that $b_0 < b_1 < b_2 < \dots < b_{n-1}$. This confirms that the algorithm correctly maintains the property of strictly increasing balances throughout its execution, which is what we set out to prove.

\end{document}

