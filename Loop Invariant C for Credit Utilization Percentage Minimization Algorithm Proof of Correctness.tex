\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}

% Using modern 'algorithm' and 'algpseudocode' packages
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsthm}

\title{Revised Proof of Correctness for Finding the Largest Credit Utilization Ratio}
\author{REMOVED_FOR_PRIVACY_REASONS}
\date{09/14/2025}

\begin{document}

\maketitle

\section{Problem Definition}

We are given a set of credit card accounts, which can be defined as follows:
\begin{itemize}
    \item $L = \langle l_1, \dots, l_{n} \rangle$ is a sequence of credit limits.
    \item $b = \langle  b_1, \dots, b_{n} \rangle$ is a sequence of corresponding credit card balances.
    \item $C = \{(b_1, l_1), \dots, (b_{n}, l_{n})\}$ is a set of tuples, where each tuple represents a single credit card account. We assume $l_i > 0$ for all $i > 0$.
    \item $n$ is the total number of credit card accounts. We assume $n > 1$.
\end{itemize}

The goal is to prove the correctness of an algorithm that finds and returns the single account tuple $(b_i, l_i)$ from $C$ with the **largest** credit utilization ratio $r_i = b_i / l_i$. The algorithm uses the following sorting key, $R'_i$:
$$ R'_i = \frac{b_{i}\sum_{j=1}^{n} (b_j/l_j)}{l_{i}} $$

\section{Pseudocode}

The algorithm first sorts the set of accounts $C$ based on the key $R'_i$ in **descending** order. Because the list is sorted this way, the account with the maximum utilization ratio is simply the first element of the sorted list.

\begin{algorithm}
\caption{FindLargestUtilizationAccount($C$)}
\begin{algorithmic}[1]
\Procedure{FindLargestUtilizationAccount}{$C$}
    \Comment{Input: A set of credit card account tuples $C = \{(b_i, l_i)\}$}
    \Comment{Output: The tuple $(b_k, l_k)$ with the largest utilization ratio $b_k/l_k$.}
    \State $R_{normalizer} \gets \sum_{i=1}^{n} (b_i/l_i)$ \Comment{Sum of all individual utilization ratios}
    \State $S \gets \Call{Sort}{C}$ \Comment{Sort $C$ by $R'_i = \frac{b_{i} \cdot R_{normalizer}}{l_{i}}$ in **descending** order}
    \State $n \gets \Call{Length}{S}$
    \If{$n > 1$}
        \For{$k \gets 1$ to $n-1$}
            \State \Comment{This loop's purpose is for the proof of correctness, verifying S is sorted.}
        \EndFor
    \EndIf
    \State \Comment{After sorting, the first element $S_1$ is the account with the largest ratio.}
    \State \Return $S_1$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Loop Invariant Proof}

We will prove the correctness of the sorting procedure using a loop invariant. The invariant is evaluated at the start of each iteration of the \textbf{FOR} loop for index $k$.

\subsection{The Invariant}

\textbf{Loop Invariant:} At the start of the iteration for a given index $k$ (where $1 \le k < n$), the following inequality holds for the elements at indices $k$ and $k+1$ in the sorted sequence $S$:
$$ \frac{b_{k}\sum_{i=1}^{n} (b_i/l_i)}{l_{k}} > \frac{b_{k+1}\sum_{i=1}^{n} (b_i/l_i)}{l_{k+1}} $$
Let $r_i = b_i/l_i$ be the utilization ratio for account $i$. The term $\sum_{i=1}^{n} (b_i/l_i)$ is the sum of all individual utilization ratios. Let's call this sum $R_{sum} = \sum_{i=1}^{n} r_i$. Since all $l_i > 0$ and we can assume at least one $b_i \ge 0$ to avoid a trivial case, $R_{sum}$ is a non-negative constant. Assuming $R_{sum} > 0$, we can divide both sides of the invariant by this constant, simplifying the invariant to:
$$ \frac{b_k}{l_k} > \frac{b_{k+1}}{l_{k+1}} $$
This demonstrates that the sorting key $R'_i$ is equivalent to the actual utilization ratio $r_i$ for sorting purposes.

\subsection{Proof by Induction}

\subsubsection{Initialization}
We must show that the invariant is true before the first loop iteration. The loop starts with $k=1$. The invariant for this case is:
$$ \frac{b_{1}\sum_{i=1}^{n} (b_i/l_i)}{l_{1}} > \frac{b_{2}\sum_{i=1}^{n} (b_i/l_i)}{l_{2}} $$
The algorithm's first active step is to sort the sequence of accounts $S$ by the key $R'_i$ in **descending** order. By the definition of this sorting operation, for any two adjacent elements $S_j$ and $S_{j+1}$, the sorting key of $S_j$ must be greater than or equal to the sorting key of $S_{j+1}$. Assuming no two accounts have the exact same utilization ratio, the key for the first element, $S_1$, is strictly **greater than** the key for the second element, $S_2$. Therefore, the invariant holds for the initial case $k=1$.

\subsubsection{Maintenance}
We assume the loop invariant holds for an arbitrary iteration $k$ (where $1 \le k < n-1$), and we must show that it also holds for the next iteration, $k+1$.

\textbf{Inductive Hypothesis:} Assume at the start of iteration $k$, the following is true:
$$ \frac{b_{k}\sum_{i=1}^{n} (b_i/l_i)}{l_{k}} > \frac{b_{k+1}\sum_{i=1}^{n} (b_i/l_i)}{l_{k+1}} $$
We need to prove that at the start of the next iteration, where the index is $k+1$, the invariant still holds. The invariant for index $k+1$ is:
$$ \frac{b_{k+1}\sum_{i=1}^{n} (b_i/l_i)}{l_{k+1}} > \frac{b_{k+2}\sum_{i=1}^{n} (b_i/l_i)}{l_{k+2}} $$
This inequality is guaranteed to be true for the same reason as in the initialization step. The sequence $S$ was sorted by the key $R'_i$ as a precondition before the loop began. The loop itself does not modify the order of elements in $S$. Thus, the sorted property holds for any pair of adjacent elements in the sequence, including $S_{k+1}$ and $S_{k+2}$. The invariant is therefore maintained through each iteration of the loop.

\subsubsection{Termination}
The loop terminates when $k$ becomes $n$. The final iteration of the loop body is for $k = n-1$.

At the start of this final iteration, the maintenance property guarantees that the invariant holds for $k = n-1$, which is:
$$ \frac{b_{n-1}\sum_{i=1}^{n} (b_i/l_i)}{l_{n-1}} > \frac{b_{n}\sum_{i=1}^{n} (b_i/l_i)}{l_{n}} $$
This is equivalent to showing $b_{n-1}/l_{n-1} > b_{n}/l_{n}$.

When the loop terminates, the invariant has held true for all values of $k$ from $1$ to $n-1$. This establishes a transitive chain of inequalities for the entire sequence based on the simplified invariant:
$$ \frac{b_1}{l_1} > \frac{b_2}{l_2} > \dots > \frac{b_{n-1}}{l_{n-1}} > \frac{b_n}{l_n} $$
This chain of inequalities is the **terminating condition** that holds true once the loop has finished. It confirms that the algorithm correctly sorts the accounts in **descending** order of their credit utilization ratio. Consequently, the algorithm correctly identifies the account with the **maximum** utilization ratio, which must be the first element of this sorted sequence, $S_1$.

\qedsymbol

\end{document}