\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}

% Using modern 'algorithm' and 'algpseudocode' packages
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsthm}

\title{Proof of Correctness for Finding the Largest Balance-Limit Product}
\author{REMOVED_FOR_PRIVACY_REASONS}
\date{09/14/2025}

\begin{document}

\maketitle

\section{Problem Definition}

We are given a set of credit card accounts, which can be defined as follows:
\begin{itemize}
    \item $L = \langle l_1, \dots, l_{n} \rangle$ is a sequence of credit limits.
    \item $b = \langle  b_1, \dots, b_{n} \rangle$ is a sequence of corresponding credit card balances.
    \item $C = \{(b_1, l_1), \dots, (b_{n}, l_{n})\}$ is a set of tuples, where each tuple represents a single credit card account. We assume $l_i > 0$ for all $i > 0$.
    \item $n$ is the total number of credit card accounts. We assume $n > 1$.
\end{itemize}

The goal is to prove the correctness of an algorithm that finds and returns the single account tuple $(b_i, l_i)$ from $C$ with the **largest** balance-limit product $p_i = b_i \cdot l_i$. The algorithm uses the following sorting key, $R_i$:
$$ R_i = \frac{b_{i}l_{i}}{\sum_{j=1}^{n} b_j l_j} $$

\section{Pseudocode}

The algorithm first sorts the set of accounts $C$ based on the key $R_i$ in **descending** order. Because the list is sorted this way, the account with the maximum balance-limit product is simply the first element of the sorted list.

\begin{algorithm}
\caption{FindLargestBalanceLimitProductAccount($C$)}
\begin{algorithmic}[1]
\Procedure{FindLargestBalanceLimitProductAccount}{$C$}
    \Comment{Input: A set of credit card account tuples $C = \{(b_i, l_i)\}$}
    \Comment{Output: The tuple $(b_k, l_k)$ with the largest balance-limit product $b_k \cdot l_k$.}
    \State $BL_{sum} \gets \sum_{i=1}^{n} b_i l_i$ \Comment{Sum of all individual balance-limit products}
    \State $S \gets \Call{Sort}{C}$ \Comment{Sort $C$ by $R_i = \frac{b_{i}l_{i}}{BL_{sum}}$ in **descending** order}
    \State $n \gets \Call{Length}{S}$
    \If{$n > 1$}
        \For{$k \gets 1$ to $n-1$}
            \State \Comment{This loop's purpose is for the proof of correctness, verifying S is sorted.}
        \EndFor
    \EndIf
    \State \Comment{After sorting, the first element $S_1$ is the account with the largest product.}
    \State \Return $S_1$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Loop Invariant Proof}

We will prove the correctness of the sorting procedure using a loop invariant. The invariant is evaluated at the start of each iteration of the \textbf{FOR} loop for index $k$.

\subsection{The Invariant}

\textbf{Loop Invariant:} At the start of the iteration for a given index $k$ (where $1 \le k < n$), the following inequality holds for the elements at indices $k$ and $k+1$ in the sorted sequence $S$:
$$ \frac{b_{k}l_{k}}{\sum_{i=1}^{n} b_i l_i} > \frac{b_{k+1}l_{k+1}}{\sum_{i=1}^{n} b_i l_i} $$
Let $BL_{sum} = \sum_{i=1}^{n} b_i l_i$. Since all $l_i > 0$ and we can assume at least one $b_i \ge 0$ to avoid a trivial case, $BL_{sum}$ is a non-negative constant. Assuming $BL_{sum} > 0$, we can multiply both sides of the invariant by this constant, simplifying the invariant to:
$$ b_k l_k > b_{k+1} l_{k+1} $$
This demonstrates that the sorting key $R_i$ is equivalent to the balance-limit product $p_i = b_i l_i$ for sorting purposes.

\subsection{Proof by Induction}

\subsubsection{Initialization}
We must show that the invariant is true before the first loop iteration. The loop starts with $k=1$. The invariant for this case is:
$$ \frac{b_{1}l_{1}}{\sum_{i=1}^{n} b_i l_i} > \frac{b_{2}l_{2}}{\sum_{i=1}^{n} b_i l_i} $$
The algorithm's first active step is to sort the sequence of accounts $S$ by the key $R_i$ in **descending** order. By the definition of this sorting operation, for any two adjacent elements $S_j$ and $S_{j+1}$, the sorting key of $S_j$ must be greater than or equal to the sorting key of $S_{j+1}$. Assuming no two accounts have the exact same balance-limit product, the key for the first element, $S_1$, is strictly **greater than** the key for the second element, $S_2$. Therefore, the invariant holds for the initial case $k=1$.

\subsubsection{Maintenance}
We assume the loop invariant holds for an arbitrary iteration $k$ (where $1 \le k < n-1$), and we must show that it also holds for the next iteration, $k+1$.

\textbf{Inductive Hypothesis:} Assume at the start of iteration $k$, the following is true:
$$ \frac{b_{k}l_{k}}{\sum_{i=1}^{n} b_i l_i} > \frac{b_{k+1}l_{k+1}}{\sum_{i=1}^{n} b_i l_i} $$
We need to prove that at the start of the next iteration, where the index is $k+1$, the invariant still holds. The invariant for index $k+1$ is:
$$ \frac{b_{k+1}l_{k+1}}{\sum_{i=1}^{n} b_i l_i} > \frac{b_{k+2}l_{k+2}}{\sum_{i=1}^{n} b_i l_i} $$
This inequality is guaranteed to be true for the same reason as in the initialization step. The sequence $S$ was sorted by the key $R_i$ as a precondition before the loop began. The loop itself does not modify the order of elements in $S$. Thus, the sorted property holds for any pair of adjacent elements in the sequence, including $S_{k+1}$ and $S_{k+2}$. The invariant is therefore maintained through each iteration of the loop.

\subsubsection{Termination}
The loop terminates when $k$ becomes $n$. The final iteration of the loop body is for $k = n-1$.

At the start of this final iteration, the maintenance property guarantees that the invariant holds for $k = n-1$, which is:
$$ \frac{b_{n-1}l_{n-1}}{\sum_{i=1}^{n} b_i l_i} > \frac{b_{n}l_{n}}{\sum_{i=1}^{n} b_i l_i} $$
This is equivalent to showing $b_{n-1}l_{n-1} > b_{n}l_{n}$.

When the loop terminates, the invariant has held true for all values of $k$ from $1$ to $n-1$. This establishes a transitive chain of inequalities for the entire sequence based on the simplified invariant:
$$ b_1 l_1 > b_2 l_2 > \dots > b_{n-1}l_{n-1} > b_n l_n $$
This chain of inequalities is the **terminating condition** that holds true once the loop has finished. It confirms that the algorithm correctly sorts the accounts in **descending** order of their balance-limit product. Consequently, the algorithm correctly identifies the account with the **maximum** balance-limit product, which must be the first element of this sorted sequence, $S_1$.

\qedsymbol

\end{document}
